% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/plot_scorable_table.R
\name{plot_pred_obs_pointintervals}
\alias{plot_pred_obs_pointintervals}
\title{Plot median predictions and prediction
intervals as pointintervals against observed data}
\usage{
plot_pred_obs_pointintervals(
  scorable_table,
  interval_widths = c(0.5, 0.95),
  horizon_col = "horizon",
  target_date_col = "target_end_date",
  predicted_col = "predicted",
  observed_col = "observed",
  quantile_level_col = "quantile_level",
  x_label = "Date",
  y_label = "Target",
  y_transform = "log10",
  quantile_tol = 10,
  predicted_point_size = 3,
  predicted_point_shape = 23,
  predicted_point_fill = "lightblue",
  predicted_interval_color = "darkblue",
  observed_point_size = 3,
  observed_point_shape = 21,
  observed_point_fill = "darkred",
  observed_linetype = "solid",
  observed_linewidth = 1,
  observed_linecolor = "black"
)
}
\arguments{
\item{scorable_table}{quantile table with observations,
as the output of \code{\link[scoringutils:as_forecast_quantile]{scoringutils::as_forecast_quantile()}},
or as a table coercible to a \code{scoringutils}-ready quantile
forecast via \code{\link[scoringutils:as_forecast_quantile]{scoringutils::as_forecast_quantile()}}. Must
contain the median (0.5) quantile and the endpoint quantiles
for the equal-tailed prediction interval specified in
\code{prediction_interval_width}. Must contain a column specifying
the forecast horizon. Plot will be faceted into rows and columns,
with rows representing different horizons and columns representing
all other forecast unit variables beside horizon and target date.}

\item{interval_widths}{Width(s) of the equal-tailed prediction
interval(s) to plot around the median. Must correspond to quantiles
available in \code{scorable_table}. Default \verb{c(0.5, 0.95})`.}

\item{horizon_col}{Name of the column in \code{scorable_table} containing
the forecast horizon for a given row. Default \code{"horizon"} (as in
hubverse schema).}

\item{target_date_col}{Name of the column in \code{scorable_table}
giving the forecast target date for a given prediction.
Default \code{"target_end_date"} (as in hubverse schema).}

\item{predicted_col}{Name of the column in \code{scorable_table}
giving the predicted values. Default \code{"predicted"} (as in
the output of \code{\link[scoringutils:as_forecast_quantile]{scoringutils::as_forecast_quantile()}}. Passed
as the \code{predicted} argument to \code{\link[scoringutils:as_forecast_quantile]{scoringutils::as_forecast_quantile()}}.}

\item{observed_col}{Name of the column in \code{scorable_table}
giving the observed values. Default \code{"observed"} (as in
the output of \code{\link[scoringutils:as_forecast_quantile]{scoringutils::as_forecast_quantile()}}. Passed
as the \code{observed} argument to \code{\link[scoringutils:as_forecast_quantile]{scoringutils::as_forecast_quantile()}}.}

\item{quantile_level_col}{Name of the column in \code{scorable_table}
giving the quantile level for a given row. Default \code{"quantile_level"}
(as in the output of \code{\link[scoringutils:as_forecast_quantile]{scoringutils::as_forecast_quantile()}}.
Passed as the \code{quantile_level} argument to
\code{\link[scoringutils:as_forecast_quantile]{scoringutils::as_forecast_quantile()}}.}

\item{x_label}{Label for the x axis in the plot. Default
\code{"Date"}.}

\item{y_label}{Label for the y axis in the plot. Default
\code{"Target"}.}

\item{y_transform}{Transformation for the y axis in the plot.
Passed as the \code{transform} argument to \code{\link[ggplot2:scale_continuous]{ggplot2::scale_y_continuous()}}
Default \code{"log10"}.}

\item{quantile_tol}{Round quantile level values to this many
decimal places, to avoid problems with floating point number
equality comparisons. Affects both the target quantile level
values determined from \code{prediction_interval_width} and the
quantile level values in the \code{quantile_level_col} column of
\code{scorable_table}. Passed as the \code{digits} argument to
\code{\link[base:Round]{base::round()}}. Default 10.}

\item{predicted_point_size}{Size for the points showing
median predictions. Passed as the \code{point_size} argument to
\code{\link[ggdist:geom_pointinterval]{ggdist::geom_pointinterval()}}. Default \code{3}.}

\item{predicted_point_shape}{Shape for the points showing
median predictions. Passed as the \code{shape} argument to
\code{\link[ggdist:geom_pointinterval]{ggdist::geom_pointinterval()}}. Default \code{23} (filled diamonds).}

\item{predicted_point_fill}{Fill color for the points showing
median predictions. Passed as the \code{point_fill} argument to
\code{\link[ggdist:geom_pointinterval]{ggdist::geom_pointinterval()}}. Default \code{"lightblue"}.}

\item{predicted_interval_color}{Color for the lines showing
predictions intervals. Passed as the \code{interval_color} argument
to \code{\link[ggdist:geom_pointinterval]{ggdist::geom_pointinterval()}} Default \code{"darkblue"}.}

\item{observed_point_size}{Size for the points showing observed
values. Passed as the \code{size} argument to \code{\link[=geom_line_point]{geom_line_point()}}.
Default \code{3}.}

\item{observed_point_shape}{Shape for the points showing
observed values. Passed as the \code{shape} argument to
\code{\link[=geom_line_point]{geom_line_point()}}. Default \code{21} (filled circles).}

\item{observed_point_fill}{Fill color for the points showing
observed values. Passed as the \code{fill} argument to
\code{\link[=geom_line_point]{geom_line_point()}}. Default \code{"darkred"}.}

\item{observed_linetype}{Type of line to connect the timeseries
of observed values. Passed as the \code{"linetype"} argument to
\code{\link[=geom_line_point]{geom_line_point()}}. Default \code{"solid"}.}

\item{observed_linewidth}{Width for the line connecting the
timeseries of observed values. Passed as the \code{"linewidth"}
argument to \code{\link[=geom_line_point]{geom_line_point()}}. Default \code{1}.}

\item{observed_linecolor}{Color for the line connecting the
timeseries of observed values. Passed as the \code{"color"}
argument to \code{\link[=geom_line_point]{geom_line_point()}}. Default \code{"black"}.}

\item{facet_columns}{Columns in \code{scorable_table} by which to
facet the resulting plot. Will always facet by \code{forecast_date_col}.
If \code{NULL}, facet by all the columns that make up the \code{scoringutils}
"forecast unit", as determined by \code{\link[scoringutils:get_forecast_unit]{scoringutils::get_forecast_unit()}},
except for \code{target_date_col} and \code{horizon}. This means that, by default,
two distinct predictions for a given target date and horizon should
not be visualized on the same facet. To facet \emph{only} by the forecast date
column, pass that column name again, or pass \code{""}.}
}
\value{
The plot, as a \code{\link[ggplot2:ggplot]{ggplot2::ggplot()}} object.
}
\description{
Plot median predictions and prediction
intervals as pointintervals against observed data
}
\examples{
scoringutils::example_quantile |>
  dplyr::filter(
    location == "IT",
    target_type == "Cases",
    model == "EuroCOVIDhub-ensemble"
  ) |>
  dplyr::select(-"forecast_date") |>
  # otherwise will get single points per facet
  # since forecast_date will be treated as a faceting
  # variable independent of horizon
  plot_pred_obs_by_pointervals()

scoringutils::example_quantile |>
  dplyr::filter(
    location == "IT",
    target_type == "Cases",
    model \%in\% c("EuroCOVIDhub-ensemble", "EuroCOVIDhub-baseline")
  ) |>
  dplyr::select(-"forecast_date") |>
  plot_pred_obs_by_pointervals()

}
