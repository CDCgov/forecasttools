#' Filter a table of forecast and target data
#' intended for scoring.
#'
#' Takes in a table generated by [create_table_for_scoring()]
#' or [scoringutils::score()] and and filters it according to
#' various parameters.
#'
#' @param forecasts_and_targets table of forecasts
#' and targets to filter for scoring.
#' @param min_forecast_date Only score forecasts dated
#' on or after this date. If `NULL`, no minimum date.
#' Default `NULL`.
#' @param max_forecast_date Only score forecasts dated
#' on or before this date. If `NULL`, no maximum date.
#' Default `NULL`.
#' @param horizons Only score forecasts with forecast
#' horizons in this vector. If `NULL`, score all horizons
#' in the table. Default `NULL`.
#' @param locations Only score forecasts for locations
#' in this vector of locations. If `NULL`, score all
#' available locations. Default `NULL`.
#' @param models Only score forecasts for models in
#' this vector of models. If `NULL`, score all
#' available models. Default `NULL`.
#' @return The filtered table
#' @export
filter_for_scoring <- function(forecasts_and_targets,
                               min_forecast_date = NULL,
                               max_forecast_date = NULL,
                               horizons = NULL,
                               locations = NULL,
                               models = NULL) {
  to_score <- forecasts_and_targets

  ## strip NA values from
  ## not yet scored tables
  if ("true_value" %in% names(to_score)) {
    cli::cli_inform(
      "Filtering out forecasts without corresponding truth data..."
    )
    to_score <- to_score |>
      dplyr::filter(!is.na(true_value))
  }

  # filter forecasts to score
  if (!is.null(min_forecast_date)) {
    cli::cli_inform(
      "Filtering out forecast dates before {min_forecast_date}"
    )
    to_score <- to_score |>
      dplyr::filter(forecast_date >= as.Date(!!min_forecast_date))
  }
  if (!is.null(max_forecast_date)) {
    cli::cli_inform(
      "Filtering out forecast dates after {max_forecast_date}"
    )
    to_score <- to_score |>
      dplyr::filter(forecast_date <= as.Date(!!max_forecast_date))
  }
  if (!is.null(horizons)) {
    cli::cli_inform(
      "Filtering out horizons not in {horizons}"
    )
    to_score <- to_score |>
      dplyr::filter(horizon %in% c(!!horizons))
  }
  if (!is.null(locations)) {
    cli::cli_inform(
      "Filtering out locations not in {locations}"
    )

    loc_codes <- forecasttools::loc_abbr_to_flusight_code(
      locations
    )
    to_score <- to_score |>
      dplyr::filter(location %in% c(!!loc_codes))
  }
  if (!is.null(models)) {
    cli::cli_inform(
      "Filtering out models not in {models}"
    )
    to_score <- to_score |>
      dplyr::filter(model %in% c(!!models))
  }

  return(to_score)
}
