#' Filter a table of forecast and target data
#' intended for scoring.
#'
#' Takes in a table generated by [create_table_for_scoring()]
#' or [scoringutils::score()] and and filters it according to
#' various parameters.
#'
#' @param forecasts_and_targets table of forecasts
#' and targets to filter for scoring.
#' @param min_forecast_date Only score forecasts dated
#' on or after this date. If `NULL`, no minimum date.
#' Default `NULL`.
#' @param max_forecast_date Only score forecasts dated
#' on or before this date. If `NULL`, no maximum date.
#' Default `NULL`.
#' @param horizons Only score forecasts with forecast
#' horizons in this vector. If `NULL`, score all horizons
#' in the table. Default `NULL`.
#' @param locations Only score forecasts for locations
#' in this vector of locations. If `NULL`, score all
#' available locations. Default `NULL`.
#' @param models Only score forecasts for models in
#' this vector of models. If `NULL`, score all
#' available models. Default `NULL`.
#' @return The filtered table
#' @export
filter_for_scoring <- function(forecasts_and_targets,
                               min_forecast_date = NULL,
                               max_forecast_date = NULL,
                               horizons = NULL,
                               locations = NULL,
                               models = NULL) {
  to_score <- forecasts_and_targets

  loc_codes <- if (!is.null(locations)) {
    us_loc_abbr_to_code(locations)
  } else {
    NULL
  }
  min_forecast_date <- if (!is.null(min_forecast_date)) {
    as.Date(min_forecast_date)
  } else {
    NULL
  }

  max_forecast_date <- if (!is.null(max_forecast_date)) {
    as.Date(max_forecast_date)
  } else {
    NULL
  }

  ## strip NA values from
  ## not yet scored tables
  if ("true_value" %in% names(to_score)) {
    cli::cli_inform(
      "Filtering out forecasts without corresponding truth data..."
    )
    to_score <- to_score |>
      dplyr::filter(!is.na(.data$true_value))
  }

  to_score <- to_score |>
    dplyr::filter(
      nullable_comparison(
        .data$forecast_date, ">=",
        !!min_forecast_date
      ),
      nullable_comparison(
        .data$forecast_date, "<=",
        !!max_forecast_date
      ),
      nullable_comparison(.data$horizon, "%in%", !!horizons),
      nullable_comparison(.data$location, "%in%", !!loc_codes),
      nullable_comparison(.data$model, "%in%", !!models)
    )
  return(to_score)
}
